<!DOCTYPE html>
<html lang="en">
<head>
  <title>Night of the Oni</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Możesz wywalić jQuery/Bootstrap jeśli chcesz, ale zostawiam, bo masz w template -->
  <script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css" rel="stylesheet">

  <style>
    /* --- Hide UE/Emscripten debug UI --- */
    #controls, #output, #log, #status, #progress, #spinner,
    .emscripten_border, .emscripten, #fullscreen_request, #clear_indexeddb,
    #buttonrow, #logwindow, #compilingmessage {
      display: none !important;
    }

    /* keep canvas full */
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }
    #canvas { width: 100vw; height: 100vh; display:block; }

    /* --- Custom PP Loading Overlay --- */
    #ppLoading{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(circle at 50% 30%, rgba(255,60,60,.18), rgba(0,0,0,.92) 60%);
      color:#fff; z-index:9999;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    .ppBox{
      width:min(560px, 92vw);
      padding:20px;
      border-radius:18px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
    }
    .ppTitle{font-size:28px; letter-spacing:1px; margin-bottom:6px}
    .ppSub{opacity:.8; margin-bottom:14px}
    .ppBar{height:10px; border-radius:999px; background:rgba(255,255,255,.14); overflow:hidden}
    #ppBarFill{height:100%; width:0%; background:rgba(255,255,255,.85); transition: width .12s linear;}
    .ppTip{opacity:.65; margin-top:12px; font-size:13px}
    #ppFullscreen{
      position:fixed; right:14px; top:14px;
      padding:10px 14px; border-radius:999px;
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.18);
      color:#fff;
    }

    /* indeterminate progress (jak nie mamy procentów) */
#ppBarFill.ppIndeterminate{
  width: 35% !important;
  animation: ppMove 1.1s infinite ease-in-out;
}
@keyframes ppMove{
  0%   { transform: translateX(-120%); }
  100% { transform: translateX(320%); }
}

/* jak chowamy overlay: fade + nie blokuje kliknięć */
#ppLoading.ppHidden{
  opacity: 0;
  pointer-events: none;
  transition: opacity .25s ease;
}

  </style>
</head>

<body>
  <div class="wrapper" id="mainarea">
    <!-- Custom Loading -->
    <div id="ppLoading">
      <div class="ppBox">
        <div class="ppTitle">NIGHT OF THE ONI</div>
        <div class="ppSub">Downloading the curse…</div>
        <div class="ppBar"><div id="ppBarFill"></div></div>
        <div class="ppTip">First load downloads ~85MB</div>
      </div>
      <button id="ppFullscreen" type="button">Fullscreen</button>
    </div>

    <!-- Canvas (UE4 will show it when ready; my JS też dopilnuje) -->
    <canvas tabindex="0" id="canvas" oncontextmenu="event.preventDefault()" style="display:none;"></canvas>

    <!-- Zostawiamy elementy template (ukryte CSSem), bo UE4 czasem do nich się odwołuje -->
    <div class="row buttonarea text-center" id="buttonrow">
      <div class="col-sm-2 text-center"></div>
      <div class="col-sm-2 text-center"><button type="button" class="btn btn-primary" onclick="try { Module['pauseMainLoop'](); } catch(e) {console.error(e);}">Pause</button></div>
      <div class="col-sm-2 text-center"><button type="button" class="btn btn-primary" onclick="try { Module['resumeMainLoop'](); } catch(e) {console.error(e);}">Resume</button></div>
      <div class="col-sm-2 text-center"><button type="button" class="btn btn-primary" onclick="var w = document.getElementById('logwindow'); w.style.display = w.style.display ? ''_attach : ''; w.style.display = w.style.display ? '' : 'none';">Toggle Log</button></div>
      <div class="col-sm-2 text-center"><button type="button" class="btn btn-primary" id="clear_indexeddb" onclick="try { deleteIndexedDBStorage(); } catch(e) {console.error(e);}">Clear IndexedDB</button></div>
      <div class="col-sm-2 text-center"><button type="button" class="btn btn-primary" id="fullscreen_request">FullScreen</button></div>
      <div class="col-sm-2 text-center"></div>
    </div>

    <div class="texthalf text-normal jumbotron" id="logwindow" style="display:none"></div>
  </div>

<script>
(function () {
  const overlay = document.getElementById('ppLoading');
  const bar = document.getElementById('ppBarFill');
  const canvas = document.getElementById('canvas');
  const btnFS = document.getElementById('ppFullscreen');

  let gotAnyProgress = false;
  let hideRequested = false;

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
  function setPct(p) {
    if (!bar) return;
    gotAnyProgress = true;
    bar.classList.remove('ppIndeterminate');
    bar.style.transform = 'none';
    bar.style.width = clamp(p, 0, 100) + '%';
  }
  function startIndeterminate(){
    if (!bar) return;
    if (!gotAnyProgress) bar.classList.add('ppIndeterminate');
  }
  function showCanvas() {
    if (canvas && canvas.style.display === 'none') canvas.style.display = 'block';
  }
  function hideOverlay() {
    if (!overlay) return;
    overlay.classList.add('ppHidden'); // znika i NIE blokuje klików
  }

  function requestFullscreen() {
    try {
      if (canvas?.requestFullscreen) canvas.requestFullscreen();
      else if (canvas?.webkitRequestFullscreen) canvas.webkitRequestFullscreen();
    } catch (e) {}
  }
  btnFS?.addEventListener('click', requestFullscreen);

  // Start: pokaż indeterminate po chwili, jeśli nie mamy %.
  setTimeout(startIndeterminate, 500);

  // Przygotuj Module zanim załaduje się PartyPixels_Test3.UE4.js
  window.Module = window.Module || {};

  // 1) Hook statusu — jeśli UE4 coś podaje typu "xx%" lub "(a/b)", złapiemy.
  const oldSetStatus = window.Module.setStatus;
  window.Module.setStatus = function (text) {
    try {
      const s = String(text);

      // (a/b)
      const frac = /\((\d+)\s*\/\s*(\d+)\)/.exec(s);
      if (frac) {
        const a = parseInt(frac[1], 10);
        const b = parseInt(frac[2], 10);
        if (b > 0) setPct(Math.round((a / b) * 100));
      }

      // xx%
      const pct = /(\d+)\s*%/.exec(s);
      if (pct) setPct(parseInt(pct[1], 10));
    } catch(e) {}

    if (typeof oldSetStatus === 'function') oldSetStatus(text);
  };

  // 2) Najpewniejsze: runtime gotowy → chowamy overlay
  // UWAGA: UE4.js czasem nadpisuje onRuntimeInitialized,
  // więc robimy wrapper, który zawsze odpali nasze.
  const ourReady = function(){
    if (hideRequested) return;
    hideRequested = true;

    // daj grze chwilę złapać focus
    showCanvas();
    setPct(100);

    // chowamy overlay po krótkim delayu
    setTimeout(hideOverlay, 150);
  };

  const prevInit = window.Module.onRuntimeInitialized;
  window.Module.onRuntimeInitialized = function(){
    try { if (typeof prevInit === 'function') prevInit(); } catch(e) {}
    ourReady();
  };

  // 3) Fallback: jeśli runtime już działa, a overlay dalej siedzi,
  // to po 8s zdejmij overlay żeby nie blokował.
  setTimeout(() => {
    if (overlay && !overlay.classList.contains('ppHidden')) {
      // jeśli gra już pokazuje canvas (albo widać coś pod spodem), zdejmij
      // ten fallback ratuje przypadki gdy UE4 nadpisze init
      showCanvas();
      hideOverlay();
    }
  }, 8000);

})();
</script>


  <!-- UE4 loader -->
  <script src="PartyPixels_Test3.UE4.js"></script>
</body>
</html>
